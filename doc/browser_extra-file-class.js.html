<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>browser/extra-file-class.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    
    <h2><a href="index.html">Overview</a></h2><h2><a href="https://github.com/copious-world/extra-file-class" target="_blank" class="menu-item" id="repository" >Github repo</a></h2><h2><a href="https://www.npmjs.com/package/extra-file-class" target="_blank" class="menu-item" id="package" >Npm package</a></h2><h3>Classes</h3>
                        <ul id="classes-ul-overflow" class="menu-contained-nav" ><li><a href="DefaultCacheTable.html">DefaultCacheTable</a><ul class='methods'><li data-type='method' style='display: none;'><a href="DefaultCacheTable.html#add_dir">add_dir</a></li><li data-type='method' style='display: none;'><a href="DefaultCacheTable.html#add_file">add_file</a></li><li data-type='method' style='display: none;'><a href="DefaultCacheTable.html#add_file_to_dir">add_file_to_dir</a></li><li data-type='method' style='display: none;'><a href="DefaultCacheTable.html#all_changed_files">all_changed_files</a></li><li data-type='method' style='display: none;'><a href="DefaultCacheTable.html#clone_file">clone_file</a></li><li data-type='method' style='display: none;'><a href="DefaultCacheTable.html#contains">contains</a></li><li data-type='method' style='display: none;'><a href="DefaultCacheTable.html#contains_file">contains_file</a></li><li data-type='method' style='display: none;'><a href="DefaultCacheTable.html#file_data">file_data</a></li><li data-type='method' style='display: none;'><a href="DefaultCacheTable.html#init">init</a></li><li data-type='method' style='display: none;'><a href="DefaultCacheTable.html#mark_changed">mark_changed</a></li><li data-type='method' style='display: none;'><a href="DefaultCacheTable.html#remove_dir">remove_dir</a></li><li data-type='method' style='display: none;'><a href="DefaultCacheTable.html#remove_file">remove_file</a></li><li data-type='method' style='display: none;'><a href="DefaultCacheTable.html#set_file_data">set_file_data</a></li></ul></li><li><a href="DirectoryCache.html">DirectoryCache</a><ul class='methods'><li data-type='method' style='display: none;'><a href="DirectoryCache.html#backup_to_directory">backup_to_directory</a></li><li data-type='method' style='display: none;'><a href="DirectoryCache.html#get_fos">get_fos</a></li><li data-type='method' style='display: none;'><a href="DirectoryCache.html#load_directory">load_directory</a></li><li data-type='method' style='display: none;'><a href="DirectoryCache.html#start">start</a></li><li data-type='method' style='display: none;'><a href="DirectoryCache.html#stop">stop</a></li></ul></li><li><a href="ExtraFileClass.FileOperations.html">ExtraFileClass.FileOperations</a><ul class='methods'><li data-type='method' style='display: none;'><a href="ExtraFileClass.FileOperations.html#data_reader">data_reader</a></li><li data-type='method' style='display: none;'><a href="ExtraFileClass.FileOperations.html#different_drive">different_drive</a></li><li data-type='method' style='display: none;'><a href="ExtraFileClass.FileOperations.html#different_drive_sync">different_drive_sync</a></li><li data-type='method' style='display: none;'><a href="ExtraFileClass.FileOperations.html#dir_maker">dir_maker</a></li><li data-type='method' style='display: none;'><a href="ExtraFileClass.FileOperations.html#dir_reader">dir_reader</a></li><li data-type='method' style='display: none;'><a href="ExtraFileClass.FileOperations.html#dir_remover">dir_remover</a></li><li data-type='method' style='display: none;'><a href="ExtraFileClass.FileOperations.html#ensure_directories">ensure_directories</a></li><li data-type='method' style='display: none;'><a href="ExtraFileClass.FileOperations.html#ensured_file_copier">ensured_file_copier</a></li><li data-type='method' style='display: none;'><a href="ExtraFileClass.FileOperations.html#ensured_file_mover">ensured_file_mover</a></li><li data-type='method' style='display: none;'><a href="ExtraFileClass.FileOperations.html#exists">exists</a></li><li data-type='method' style='display: none;'><a href="ExtraFileClass.FileOperations.html#file_copier">file_copier</a></li><li data-type='method' style='display: none;'><a href="ExtraFileClass.FileOperations.html#file_mover">file_mover</a></li><li data-type='method' style='display: none;'><a href="ExtraFileClass.FileOperations.html#file_remover">file_remover</a></li><li data-type='method' style='display: none;'><a href="ExtraFileClass.FileOperations.html#is_dir">is_dir</a></li><li data-type='method' style='display: none;'><a href="ExtraFileClass.FileOperations.html#is_dirSync">is_dirSync</a></li><li data-type='method' style='display: none;'><a href="ExtraFileClass.FileOperations.html#is_file">is_file</a></li><li data-type='method' style='display: none;'><a href="ExtraFileClass.FileOperations.html#is_fileSync">is_fileSync</a></li><li data-type='method' style='display: none;'><a href="ExtraFileClass.FileOperations.html#json_data_reader">json_data_reader</a></li><li data-type='method' style='display: none;'><a href="ExtraFileClass.FileOperations.html#load_data_at_path">load_data_at_path</a></li><li data-type='method' style='display: none;'><a href="ExtraFileClass.FileOperations.html#load_json_data_at_path">load_json_data_at_path</a></li><li data-type='method' style='display: none;'><a href="ExtraFileClass.FileOperations.html#output_append_string">output_append_string</a></li><li data-type='method' style='display: none;'><a href="ExtraFileClass.FileOperations.html#output_json">output_json</a></li><li data-type='method' style='display: none;'><a href="ExtraFileClass.FileOperations.html#output_string">output_string</a></li><li data-type='method' style='display: none;'><a href="ExtraFileClass.FileOperations.html#watch">watch</a></li><li data-type='method' style='display: none;'><a href="ExtraFileClass.FileOperations.html#write_append_string">write_append_string</a></li><li data-type='method' style='display: none;'><a href="ExtraFileClass.FileOperations.html#write_out_json">write_out_json</a></li><li data-type='method' style='display: none;'><a href="ExtraFileClass.FileOperations.html#write_out_pretty_json">write_out_pretty_json</a></li><li data-type='method' style='display: none;'><a href="ExtraFileClass.FileOperations.html#write_out_string">write_out_string</a></li></ul></li><li><a href="ExtraFileClass.FsExtra.html">ExtraFileClass.FsExtra</a><ul class='methods'><li data-type='method' style='display: none;'><a href="ExtraFileClass.FsExtra.html#areIdentical">areIdentical</a></li><li data-type='method' style='display: none;'><a href="ExtraFileClass.FsExtra.html#copy">copy</a></li><li data-type='method' style='display: none;'><a href="ExtraFileClass.FsExtra.html#copySync">copySync</a></li><li data-type='method' style='display: none;'><a href="ExtraFileClass.FsExtra.html#createFile">createFile</a></li><li data-type='method' style='display: none;'><a href="ExtraFileClass.FsExtra.html#createFileSync">createFileSync</a></li><li data-type='method' style='display: none;'><a href="ExtraFileClass.FsExtra.html#createLink">createLink</a></li><li data-type='method' style='display: none;'><a href="ExtraFileClass.FsExtra.html#createLinkSync">createLinkSync</a></li><li data-type='method' style='display: none;'><a href="ExtraFileClass.FsExtra.html#createSymlink">createSymlink</a></li><li data-type='method' style='display: none;'><a href="ExtraFileClass.FsExtra.html#createSymlinkSync">createSymlinkSync</a></li><li data-type='method' style='display: none;'><a href="ExtraFileClass.FsExtra.html#emptyDir">emptyDir</a></li><li data-type='method' style='display: none;'><a href="ExtraFileClass.FsExtra.html#emptyDirSync">emptyDirSync</a></li><li data-type='method' style='display: none;'><a href="ExtraFileClass.FsExtra.html#ensureDirSync">ensureDirSync</a></li><li data-type='method' style='display: none;'><a href="ExtraFileClass.FsExtra.html#getStats">getStats</a></li><li data-type='method' style='display: none;'><a href="ExtraFileClass.FsExtra.html#getStatsSync">getStatsSync</a></li><li data-type='method' style='display: none;'><a href="ExtraFileClass.FsExtra.html#isSrcSubdir">isSrcSubdir</a></li><li data-type='method' style='display: none;'><a href="ExtraFileClass.FsExtra.html#makeDir">makeDir</a></li><li data-type='method' style='display: none;'><a href="ExtraFileClass.FsExtra.html#makeDirSync">makeDirSync</a></li><li data-type='method' style='display: none;'><a href="ExtraFileClass.FsExtra.html#mkdirpSync">mkdirpSync</a></li><li data-type='method' style='display: none;'><a href="ExtraFileClass.FsExtra.html#mkdirs">mkdirs</a></li><li data-type='method' style='display: none;'><a href="ExtraFileClass.FsExtra.html#move">move</a></li><li data-type='method' style='display: none;'><a href="ExtraFileClass.FsExtra.html#moveSync">moveSync</a></li><li data-type='method' style='display: none;'><a href="ExtraFileClass.FsExtra.html#outputFile">outputFile</a></li><li data-type='method' style='display: none;'><a href="ExtraFileClass.FsExtra.html#outputFileSync">outputFileSync</a></li><li data-type='method' style='display: none;'><a href="ExtraFileClass.FsExtra.html#outputJson">outputJson</a></li><li data-type='method' style='display: none;'><a href="ExtraFileClass.FsExtra.html#outputJsonSync">outputJsonSync</a></li><li data-type='method' style='display: none;'><a href="ExtraFileClass.FsExtra.html#pathExists">pathExists</a></li><li data-type='method' style='display: none;'><a href="ExtraFileClass.FsExtra.html#readJson">readJson</a></li><li data-type='method' style='display: none;'><a href="ExtraFileClass.FsExtra.html#readJsonSync">readJsonSync</a></li><li data-type='method' style='display: none;'><a href="ExtraFileClass.FsExtra.html#remove">remove</a></li><li data-type='method' style='display: none;'><a href="ExtraFileClass.FsExtra.html#removeSync">removeSync</a></li></ul></li><li><a href="FileOperationsCache.html">FileOperationsCache</a><ul class='methods'><li data-type='method' style='display: none;'><a href="FileOperationsCache.html#_file_entry_maker">_file_entry_maker</a></li><li data-type='method' style='display: none;'><a href="FileOperationsCache.html#_file_remover_cache">_file_remover_cache</a></li><li data-type='method' style='display: none;'><a href="FileOperationsCache.html#dir_maker">dir_maker</a></li><li data-type='method' style='display: none;'><a href="FileOperationsCache.html#dir_remover">dir_remover</a></li><li data-type='method' style='display: none;'><a href="FileOperationsCache.html#ensure_directories">ensure_directories</a></li><li data-type='method' style='display: none;'><a href="FileOperationsCache.html#exists">exists</a></li><li data-type='method' style='display: none;'><a href="FileOperationsCache.html#file_copier">file_copier</a></li><li data-type='method' style='display: none;'><a href="FileOperationsCache.html#file_remover">file_remover</a></li><li data-type='method' style='display: none;'><a href="FileOperationsCache.html#init">init</a></li><li data-type='method' style='display: none;'><a href="FileOperationsCache.html#load_json_data_at_path">load_json_data_at_path</a></li><li data-type='method' style='display: none;'><a href="FileOperationsCache.html#startup_sync">startup_sync</a></li><li data-type='method' style='display: none;'><a href="FileOperationsCache.html#stop_sync">stop_sync</a></li><li data-type='method' style='display: none;'><a href="FileOperationsCache.html#synch_files">synch_files</a></li><li data-type='method' style='display: none;'><a href="FileOperationsCache.html#update_at_path">update_at_path</a></li><li data-type='method' style='display: none;'><a href="FileOperationsCache.html#write_out_json">write_out_json</a></li><li data-type='method' style='display: none;'><a href="FileOperationsCache.html#write_out_string">write_out_string</a></li></ul></li><li><a href="FileOperationsWeb.html">FileOperationsWeb</a><ul class='methods'><li data-type='method' style='display: none;'><a href="FileOperationsWeb.html#add_file">add_file</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWeb.html#check_user_dir_support">check_user_dir_support</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWeb.html#copy">copy</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWeb.html#createFile">createFile</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWeb.html#data_reader">data_reader</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWeb.html#different_drive">different_drive</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWeb.html#dir_locus">dir_locus</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWeb.html#dir_maker">dir_maker</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWeb.html#dir_reader">dir_reader</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWeb.html#dir_remover">dir_remover</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWeb.html#emptyDir">emptyDir</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWeb.html#ensure_directories">ensure_directories</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWeb.html#ensured_file_copier">ensured_file_copier</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWeb.html#ensured_file_mover">ensured_file_mover</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWeb.html#exists">exists</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWeb.html#exists_dir">exists_dir</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWeb.html#file_copier">file_copier</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWeb.html#file_locus">file_locus</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWeb.html#file_maker">file_maker</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWeb.html#file_mover">file_mover</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWeb.html#file_remover">file_remover</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWeb.html#get_parent_dirs">get_parent_dirs</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWeb.html#in_web_worker">in_web_worker</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWeb.html#interactive_file_download">interactive_file_download</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWeb.html#interactive_file_retrieval">interactive_file_retrieval</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWeb.html#interactive_permission">interactive_permission</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWeb.html#is_dir">is_dir</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWeb.html#is_file">is_file</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWeb.html#json_data_reader">json_data_reader</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWeb.html#load_data_at_path">load_data_at_path</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWeb.html#load_json_data_at_path">load_json_data_at_path</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWeb.html#makeDir">makeDir</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWeb.html#make_parent_locus_dirs">make_parent_locus_dirs</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWeb.html#make_parent_opfs_dirs">make_parent_opfs_dirs</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWeb.html#make_parent_user_dirs">make_parent_user_dirs</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWeb.html#mkdirs">mkdirs</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWeb.html#move">move</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWeb.html#outputFile">outputFile</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWeb.html#outputJson">outputJson</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWeb.html#output_append_string">output_append_string</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWeb.html#output_json">output_json</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWeb.html#output_string">output_string</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWeb.html#readJson">readJson</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWeb.html#schedule_user_dir_request">schedule_user_dir_request</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWeb.html#verifyPermission">verifyPermission</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWeb.html#wait_initialization">wait_initialization</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWeb.html#watch">watch</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWeb.html#write_append_string">write_append_string</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWeb.html#write_out_json">write_out_json</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWeb.html#write_out_string">write_out_string</a></li></ul></li><li><a href="FileOperationsWebSync.html">FileOperationsWebSync</a><ul class='methods'><li data-type='method' style='display: none;'><a href="FileOperationsWebSync.html#close_sync">close_sync</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWebSync.html#copySync">copySync</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWebSync.html#get_sync_readable">get_sync_readable</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWebSync.html#get_sync_writeable">get_sync_writeable</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWebSync.html#outputFileSync">outputFileSync</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWebSync.html#outputJsonSync">outputJsonSync</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWebSync.html#pathExists">pathExists</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWebSync.html#readFileSync">readFileSync</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWebSync.html#readJsonSync">readJsonSync</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWebSync.html#sync_read">sync_read</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWebSync.html#sync_read_at_path">sync_read_at_path</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWebSync.html#sync_write">sync_write</a></li><li data-type='method' style='display: none;'><a href="FileOperationsWebSync.html#sync_write_at_path">sync_write_at_path</a></li></ul></li><li><a href="PathManager.html">PathManager</a><ul class='methods'><li data-type='method' style='display: none;'><a href="PathManager.html#add_abbreviation">add_abbreviation</a></li><li data-type='method' style='display: none;'><a href="PathManager.html#compile_one_path">compile_one_path</a></li><li data-type='method' style='display: none;'><a href="PathManager.html#compile_paths">compile_paths</a></li><li data-type='method' style='display: none;'><a href="PathManager.html#default_realtive_asset_dir">default_realtive_asset_dir</a></li><li data-type='method' style='display: none;'><a href="PathManager.html#extract_abbreviations">extract_abbreviations</a></li><li data-type='method' style='display: none;'><a href="PathManager.html#extract_delimited">extract_delimited</a></li><li data-type='method' style='display: none;'><a href="PathManager.html#extract_vars">extract_vars</a></li><li data-type='method' style='display: none;'><a href="PathManager.html#get_var">get_var</a></li><li data-type='method' style='display: none;'><a href="PathManager.html#path_abreviations">path_abreviations</a></li><li data-type='method' style='display: none;'><a href="PathManager.html#path_vars">path_vars</a></li><li data-type='method' style='display: none;'><a href="PathManager.html#pop_dir">pop_dir</a></li><li data-type='method' style='display: none;'><a href="PathManager.html#set_var">set_var</a></li><li data-type='method' style='display: none;'><a href="PathManager.html#subst_vars">subst_vars</a></li><li data-type='method' style='display: none;'><a href="PathManager.html#translate_marker">translate_marker</a></li></ul></li></ul>
                    
    
</nav>

<div id="main">
    
    <h1 class="page-title">browser/extra-file-class.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @classdesc
 * 
 * The FileOperationsWeb class wraps the same method names as FileOperations, but does it for web pages.
 * As such, this class uses the Origin Private File Sytems and the FileSystem classes available in 
 * browser implementations.
 * 
 * Synchronous operations are not available to web wokers. So, the class is broken into two classes, 
 * a promise based on and a synchrnous based one.
 * 
 * By default this class supports working with files in the Origin Private File System.
 * It may be configured to support working with files on the user's device or remote files.
 * 
 * Files on the user's device will be introduced into the object class instance of FileOperationsWeb by 
 * either the File System Access API or the FilesAndDirectories API.
 * 
 * 
 */

class FileOperationsWeb {

    /**
     * 
     * The constructor gets a hanlde to the Origin Private File System.
     * (It uses the promise "then" construct... )
     * And, it gets a handel to the user permitted device file system. 
     * If configured to do so.
     * 
     * The constructor also sets up a cache for file handles in the different file systems for later 
     * searching and access. The cache is an a JavaScript object with three top level fields "opfs", "user", and "remote".
     * 
     * Each of these has two maps, "files" and "changed". The "files" will map file paths to file handles. 
     * 
     * 
     * @param {object} conf 
     */
    constructor (conf) {
        if ( conf === undefined ) {
            conf = {}
        }
        //
        this.conf = conf   // methods having to do with directory and file picking
        this.opfs_root = false;
        this.textEncoder = new TextEncoder();
        this.textDecoder = new TextDecoder();
        //
        this.observers = {}
        //
        this.initializer_promise = new Promise((resolve,reject) => {
            navigator.storage.getDirectory().then((opfs) => {
                this.opfs_root = opfs
                resolve(opfs)
            }).catch((e) => {
                console.log("this shouldn't happen")
                reject(e)
            })
        })
        //
        this.top_dir = false
        this.user_dirs_supported = this.check_user_dir_support()
        this.top_dir_name = ""
        
        if ( conf.use_file_system ) {       // conf may be set up to show a modal on timeout or it may just attach handler to a button
            if ( typeof conf.top_dir_name === "string" ) {
                this.top_dir_name = conf.top_dir_name
            }
            this.schedule_user_dir_request(conf)       // the browser (if it suppors dir selection) needs a gesture (button click)
        }
        if ( typeof conf.remote  === 'object' ) {
            this.remote_file_com = conf.remote
        }
        //
        this.accessed = {
            "opfs" : {
                "files" : {},
                "dirs" : {},
                "changed" : {}
            },
            "user" : {
                "files" : {},
                "dirs" : {},
                "changed" : {}
            },
            "remote" : {
                "files" : {},
                "dirs" : {},
                "changed" : {}
            }
        }

        this.sync_handles = {
            "readables" : {},
            "writeables" : {}
        }
    }

 
    /**
     * 
     * This metho reports on whether or not it is in the main thread belonging to the window.
     * If it is not in the window, it returns 2 for finding "Worker" in the name of the thread
     * constructor.
     * 
     * This method returns false if the window global variable is defined.
     * 
     * @returns boolean | Number
     */
    in_web_worker() {
        if ( (typeof window === "undefined" ) ) {
            if ( self.constructor.name.indexOf("Worker") ) {
                return 2
            }
            return true
        }
        return false
    }

    /**
     * Wait for an constructor based initialization process to complete.
     * This is especially important in a Worker thread, where there is no user
     * interaction.
     * 
     * It is recommended for a thread's function that creates a FileOperationsWeb 
     * instance to await this immediately after calling.
     * 
     */
    async wait_initialization() {
        if ( this.initializer_promise ) {
           await this.initializer_promise
           this.initializer_promise = false
        }
    }

    /**
     * Verify the user has granted permission to read or write to the file, if
     * permission hasn't been granted, request permission.
     *
     * @param {FileSystemFileHandle} fileHandle File handle to check.
     * @param {boolean} withWrite True if write permission should be checked.
     * @return {boolean} True if the user has granted read/write permission.
     */
    async verifyPermission(fileHandle, withWrite) {
        try {
            const opts = {};
            if (withWrite) {
                opts.writable = true;
                // For Chrome 86 and later...
                opts.mode = 'readwrite';
            }
            // Check if we already have permission, if so, return true.
            if (await fileHandle.queryPermission(opts) === 'granted') {
                return true;
            }
            // Request permission to the file, if the user grants permission, return true.
            if (await fileHandle.requestPermission(opts) === 'granted') {
                return true;
            }
        } catch (e) {
            return false
        }
        // The user didn't grant permission, return false.
        return false;
    }


    /**
     * Search the directory identified by *path* in different locations (as previously recorded by add_file)
     * 
     * @param {string} path 
     * @returns string | boolean
     */
    dir_locus(path,options) {
        if ( options.locus ) {
            let lmap = this.accessed[options.locus]
            if ( lmap ) {
                let entry = lmap.files[path]
                if ( entry ) {
                    return options.locus
                }
            }
        } else {
            let entry = this.accessed.opfs.dirs[path]
            if ( entry ) {
                return "opfs"
            }
            //
            if ( (this.top_dir !== false) ) {
                entry = this.accessed.user.dirs[path]
                if ( entry ) {
                    return "user"
                }
            }
            //
            entry = this.accessed.remote.dirs[path]
            if ( entry ) {
                return "remote"
            }
        }
        //
        return false
    }


    /**
     * Search the file identified by *path* in different locations (as previously recorded by add_file)
     * 
     * @param {string} path 
     * @returns string | bpolean
     */
    file_locus(path,options) {
        if ( options.locus ) {
            let lmap = this.accessed[options.locus]
            if ( lmap ) {
                let entry = lmap.files[path]
                if ( entry ) {
                    return options.locus
                }
            }
        } else {
            let entry = this.accessed.opfs.files[path]
            if ( entry ) {
                return "opfs"
            }
            //
            entry = this.accessed.user.files[path]
            if ( entry ) {
                return "user"
            }
            //
            entry = this.accessed.remote.files[path]
            if ( entry ) {
                return "remote"
            }
        }
        //
        return false
    }





    /**
     * different_drive
     * 
     * Uses the file system stat methods to determine if the files are on different drives
     * 
     * @param {string} src 
     * @param {string} dest 
     */
    async different_drive(src,dest) {
        if ( this.accessed.opfs.files[src] &amp;&amp; this.accessed.opfs.files[dest]) {
            return false
        }
        if ( this.accessed.user.files[src] &amp;&amp; this.accessed.user.files[dest]) {
            return false
        }
        if ( this.accessed.remote.files[src] &amp;&amp; this.accessed.remote.files[dest]) {
            return false
        }
        return true
    }

    /**
     * is_dir
     * 
     * Calls on lstat, and if the directory exists, 
     * this will return the result of isDirectory
     * 
     * @param {string} path 
     * @returns boolean
     */
    async is_dir() {
        if ( this.accessed.opfs.dirs[src] ) {
            return true
        }
        if ( (this.top_dir !== false) &amp;&amp; this.accessed.user.dirs[src] ) {
            return true
        }
        if ( this.accessed.remote.dirs[src] ) {
            return true
        }
        return false
    }


    /**
     * is_file
     * 
     * Calls on lstat, and if the directory exists, 
     * this will return the result of isFile
     * 
     * @param {string} path 
     * @returns boolean
     */
    async is_file() {
        if ( this.accessed.opfs.files[src] ) {
            return true
        }
        if ( (this.top_dir !== false) &amp;&amp; this.accessed.user.files[src] ) {
            return true
        }ce_flags
        if ( this.accessed.remote.files[src] ) {
            return true
        }
        return false
    }



    // ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----


    /**
     * 
     * This method ensures that existing directories are stored within the "accessed" table.
     * This method accesses the directory structure attempting to get each directory in a path.
     * The other method, `make_parent_locus_dirs`, will create directories.
     * 
     * This method returns a pair.
     * 
     * This method will return a pair including a directory handle if all the directories exists. This directory 
     * handle will be the first part of a pair.
     * 
     * The second part the pair will either be the lowest level directory of the path, or it will be a file name 
     * of the path.
     * 
     * In some cases, an application will need all the directories in a path to exist. And, the final path is the 
     * handle required. It may helps to pass a path with a dummy directory/file at the end. For example:
     * `top/next/bottom/*`.
     * 
     * 
     * 
     * @param {string} path 
     * @param {string} locus 
     * @returns object | boolean  (dirHandle or false)
     */
    async get_parent_dirs(path,locus) {
        let pth = path
        let target_d = path
        let path_parts = []
        if ( pth.indexOf('/') > 0 ) {
            path_parts = pth.split('/')
            target_d = path_parts.pop()
        } else {
            return [this.top_dir,target_d]
        }
        let dir_handle = this.accessed[locus].dirs[pth]
        if ( dir_handle !== undefined ) {
            return dir_handle
        }
        //
        dir_handle = this.top_dir
        let bread_crumb = this.top_dir_name
        if ( path_parts[0] === this.top_dir_name ) {
            path_parts.shift()
        }
        //
        for ( let dname of path_parts ) {
            bread_crumb += `/${dname}`
            let d_handle = this.accessed[locus].dirs[bread_crumb]
            if ( d_handle === undefined ) {
                d_handle = dir_handle.getDirectory(dname)
                if ( d_handle ) {
                    this.accessed[locus].dirs[bread_crumb] = d_handle
                    dir_handle = d_handle
                }
            }
            if ( dir_handle === undefined ) {
                return [false,false]
            }
        }
        if ( dir_handle === undefined ) {
            return [false,false]
        }
        return [dir_handle,target_d]
    }




    /**
     * 
     * Given a path to a file, this method obtains a handle for it, useful for later operations.
     * The handle will be derived in the file system specified in *locus*. 
     * The file handle will stored in the table, accessed under its locus in the file table.
     * 
     * This calls `get_parent_dirs`.
     * 
     * @param {string} path 
     * @param {string} locus 
     */
    async add_file(path,locus) {
        if ( locus === undefined ) {
            locus = "opfs"
        }
        let file_handle = false
        try {
            let [parent_dir,target] = await this.get_parent_dirs(path,locus)
            if ( parent_dir ) {
                file_handle = await parent_dir.getFileHandle(target);
            }
            //
            if ( file_handle ) {
                this.accessed[locus].files[path] = file_handle;
            }
            //
        } catch (e) {
            return false
        }
        return file_handle
    }



    /**
     * 
     * This method creates all the directories in a path if they don't exists yet.
     * It uses the method `getDirectoryHandle` with the option "create" set to true.
     * 
     * This method is general with regard to locus (the file system choice).
     * `locus` may be set to "user", "opfs", "remote".
     * 
     * @param {string} path 
     * @param {string} locus 
     * @param {object} top_dir - a file system handle to the top directory
     * @param {string} top_dir_name 
     * @param {object} options 
     * @returns object | boolean  (dirHandle or false)
     */

    async make_parent_locus_dirs(path,locus,top_dir,top_dir_name,options) {
        let pth = path
        let target = ""
        if ( pth.indexOf('/') > 0 ) {
            pth = path.substring(0,path.lastIndexOf('/'))
            target = path.substring(path.lastIndexOf('/')+1)
        } else {
            return [top_dir,pth]
        }
        let dir_handle = this.accessed[locus].dirs[pth]
        if ( dir_handle !== undefined ) {
            return [dir_handle,target]
        }
        if ( options.recursive ) {
            let path_parts = pth.split('/')
            //
            let bread_crumb = top_dir_name
            if ( path_parts[0] === top_dir_name ) {
                path_parts.shift()
            }
            let dir_h = top_dir
            //
            for ( let dname of path_parts ) {4
                try {
                    bread_crumb += `/${dname}`
                    const directoryHandle = await dir_h.getDirectoryHandle(dname,{create : true });
                    this.accessed[locus].dirs[bread_crumb] = directoryHandle
                    dir_h = directoryHandle
                } catch (e) {
                    return [false,false]
                }
            }
        }
        return [false,false]
    }

    /**
     * This method is a specialization of `make_parent_locus_dirs` with locus set to "user"
     * 
     * @param {*} path 
     * @param {*} options 
     * @returns pair
     */
    async make_parent_user_dirs(path,options) {
        return await this.make_parent_locus_dirs(path,"user",this.top_dir,this.top_dir_name,options)
    }

    /**
     * This method is a specialization of `make_parent_locus_dirs` with locus set to "opfs"
     * 
     * @param {*} path 
     * @param {*} options 
     * @returns pair
     */
    async make_parent_opfs_dirs(path,options) {
        return await this.make_parent_locus_dirs(path,"opfs",this.opfs_root,"",options)
    }

    // ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----

    /**
     * dir_maker
     * 
     * create a directory -- assume parent directory exists
     * > guards against THROW
     * 
     * 
     * @param {string} path -- a path to the directory to be created
     * @param {object} options
     * 
     * @returns boolean
     */
    async dir_maker(path,options) {
        if ( options === undefined ) {
            options = {}
        }
        if ( (options.locus === "user") &amp;&amp; !(this.user_dirs_supported) ) {
            return false
        }
        try {
            let pth = path
            if ( path.indexOf('/') > 0 ) {
                pth = `${path}/*`
            }
            if ( pth[0] === '/' ) {
                pth = pth.substring(1)
            }
            if ( (options.locus == "remote") || (options.locus === "user") ) {
                if ( options.remote &amp;&amp; (typeof this.remote_file_com === "function") ) {
                    let directoryHandle = await this.remote_file_com.dir_maker(path)
                    if ( directoryHandle ) this.accessed.remote.dirs[path] = directoryHandle
                } else if ( (options.locus === "user") &amp;&amp; (this.top_dir !== false) ) {
                    let opts = Object.assign({create : true },options)
                    delete opts.locus
                    let ok = await this.verifyPermission(this.top_dir,true)
                    if ( !ok ) {
                        ok = await this.interactive_permission()
                    }
                    if ( ok ) {
                        await this.make_parent_user_dirs(pth,options)
                    }
                } else {
                    return false
                }
            } else {
                await this.make_parent_opfs_dirs(pth,options)
            }
        } catch(e) {
            return false
        }
        return true
    }


    /**
     * file_maker
     * 
     * create a file -- assume parent directory exists
     * > guards against THROW
     * 
     * 
     * @param {string} path -- a path to the directory to be created
     * @param {object} options
     * 
     * @returns boolean
     */
    async file_maker(path,options) {
        if ( options === undefined ) {
            options = {}
        }
        try {
            if ( (options.locus == "remote") || (options.locus === "user") ) {
                if ( options.remote &amp;&amp; (typeof this.remote_file_com === "function") ) {
                    let fileHandle = await this.remote_file_com.file_maker(path)
                    if ( fileHandle ) this.accessed.remote.files[path] = fileHandle
                } else if ( (options.locus === "user") &amp;&amp; (this.top_dir !== false) ) {
                    let ok = await this.verifyPermission(this.top_dir,true)
                    if ( !ok ) {
                        ok = await this.interactive_permission()
                    }
                    // target will be the file name
                    let [dir_handle,target] = ok ? await this.make_parent_user_dirs(path,options) : [false,false]
                    if ( ok &amp;&amp; dir_handle ) {
                        let opts = Object.assign({create : true },options)
                        delete opts.locus
                        const fileHandle = await dir_handle.getFileHandle(target,opts);
                        this.accessed.user.files[path] = fileHandle
                    }
                } else {
                    return false
                }
            } else {
                // target will be the file name
                let [dir_handle,target] = await this.make_parent_opfs_dirs(path,options)
                if ( dir_handle ) {
                    let opts = Object.assign({create : true },options)
                    delete opts.locus
                    const fileHandle = await dir_handle.getFileHandle(target,opts);
                    this.accessed.opfs.files[path] = fileHandle
                }
            }
        } catch(e) {
            return false
        }
        return true
    }


    /**
     * ensure_directories
     * 
     * -- attempts to construct or verify all directories along the path up to an optional file
     * -- guards against THROW
     * -- parameter :: path 
     * 
     * @param {string} path -- a path to the file to be removed
     * @param {string} top_dir -- an optional top level directy path under which directories will be created  
     * @param {string} locus -- one of "remote", "user", "opfs"
     * @param {boolean} is_file_path -- optional -- true if the path is for a file (does not try to figure this out)
     * @param {Function} app_cb -- optional -- a callback (parent_directroy,file) => {} available to subclasses for ops and bookkeeping
     * 
     * @returns string | boolean
     */
    async ensure_directories(a_path,top_dir,locus,is_file_path,app_cb) {
        //
        if ( (this.top_dir !== false) &amp;&amp; (locus === "user") ) {
            console.log("user file system not supported in this browser")
            return false
        }
        //
        let sep = path.sep
        let c_path = top_dir ? `${top_dir}${sep}${a_path}` : a_path
        let file = ""
        if ( is_file_path ) {
            file = path.basename(c_path)
            c_path = path.dirname(c_path)
        }
        //
        let status = await this.dir_maker(c_path,{ "recursive" : true, "locus" : locus })
        if ( status ) {
            if ( is_file_path ) {
                let file_path = [c_path,file].join(sep)   // includes the top dir parameter possibly
                if ( typeof app_cb === 'function' ) {
                    app_cb(c_path,file_path)  // the file is known to be bottom of the path
                }
                c_path = file_path
            }
            return c_path       // top dir + path + file (if there it is a file)
        }
        return false
    }

    /**
     * dir_remover
     * 
     * -- remove a directory -- assume parent directory exists
     * -- parameter :: upath 
     * 
     * @param {string} upath -- a path to the directory to be removed
     * @param {boolean} recursive -- from fsPromises 'rm' -- will remove subdirectories if true
     * @returns boolean
     */
    async dir_remover(upath,options,recursive = false) {
        let locus = this.dir_locus(path,(((typeof options === "object") &amp;&amp; options.locus) ? options.locus : undefined))
        if ( !locus ) { locus = "opfs" }
        try {
            let [dir_handle,target] = this.get_parent_dirs(upath,locus)
            if ( dir_handle ) {
                if ( recursive ) {
                    await dir_handle.removeEntry(target,{ 'recursive': true })
                } else {
                    await dir_handle.removeEntry(target)
                }
                delete this.accessed[locus].dirs[upath]
            }
        } catch(e) {
            return false
        }
        return true
    }


    /**
     * dir_reader
|     * 
     * returns a list of files from the directory at path
     * if there is an error returns []
     * 
     * @param {string} path 
     * @returns array - the list of files in the directory
     */
    async dir_reader(path,options) {
        let locus = this.dir_locus(path,(((typeof options === "object") &amp;&amp; options.locus) ? options.locus : undefined))
        if ( !locus ) locus = "opfs"
        try {
            let upath = path + "/*"
            let [dir_handle,target] = this.get_parent_dirs(upath,locus)
            let files = []
            if ( dir_handle ) {
                files = dir_handle.keys()
            }
            return files
        } catch (e) {
            console.error(e);
        }
        return [] 
    }

    
    /**
     * 
     * file_remover
     * 
     * -- remove a directory -- assume a valid path
     * -- guards against THROW
     * 
     * @param {string} path -- a path to the file to be removed
     * @returns boolean
     */
    async file_remover(path,options) {
        let locus = this.file_locus(path,(((typeof options === "object") &amp;&amp; options.locus) ? options.locus : undefined))
        if ( !locus ) { locus = "opfs" }
        //
        try {
            let [dir_handle,target] = this.get_parent_dirs(path,locus)
            if ( dir_handle ) {
                await dir_handle.removeEntry(target,{ 'recursive': true })
                delete this.accessed[locus].files[path]
            }
        } catch(e) {
            return false
        }
        return true
    }


    /**
     * write_out_string
     * 
     * -- write string to file -- assume a valid path
     * -- guards against THROW
     * 
     * @param {string} path -- a path to the file that will contain the string
     * @param {string} str -- a string to be written
     * @param {object} options -- options -- refer to the flags for node.js writeFile having to do with permissions, format, etc.
     * @returns boolean
     */
    async write_out_string(path,str,options) {
        let locus = this.file_locus(path,(((typeof options === "object") &amp;&amp; options.locus) ? options.locus : undefined))
        if ( !locus ) {
            await this.file_maker(path,options)
            locus = this.file_locus(path,options)
        }
        try {
            let file_handle = false
            if ( ( locus === "user" ) || ( locus === "opfs" ) || ( locus === "remote" ) ) {
                file_handle = this.accessed[locus].files[path]
                if ( file_handle ) {
                    const writable = await file_handle.createWritable();
                    const content = this.textEncoder.encode(str);
                    writable.write(content);
                    // Close the file and write the contents to disk.
                    await writable.close();
                }
            } else {
                return false
            }
        } catch(e) {
            return false
        }
        return true
    }


    /**
     * 
     * write_append_string
     * 
     * -- append string to the end of a file -- assume a valid path
     * -- guards against THROW
     * 
     * @param {string} path -- a path to the file that will contain the string
     * @param {string} str -- a string to be written
     * @param {object} options -- options -- refer to the flags for node.js writeFile having to do with permissions, format, etc.
     * @returns boolean
     */
    async write_append_string(path,str,options) {
        let locus = this.file_locus(path,(((typeof options === "object") &amp;&amp; options.locus) ? options.locus : undefined))
        if ( !locus ) {
            let test_handle = false
            if ( options.locus ) {
                test_handle = await this.add_file(path,options.locus)
                if ( !test_handle ) {
                    await this.file_maker(path,options)
                }
                locus = this.file_locus(path)
            }
        }
        try {
            let file_handle = false
            if ( ( locus === "user" ) || ( locus === "opfs" ) || ( locus === "remote" ) ) {
                file_handle = this.accessed[locus].files[path]
                if ( file_handle ) {
                    const writable = await file_handle.createWritable();
                    const content = this.textEncoder.encode(str);
                    const size = file_handle.getSize()
                    writable.write(content, { at: size });
                    // Close the file and write the contents to disk.
                    await writable.close();
                }
            } else {
                return false
            }
        } catch(e) {
            return false
        }
        return true
    }


    /**
     * data_reader
     * 
     * -- read a file from disk --- any format
     * -- will THROW
     * 
     * This file returns the blob, and does not convert the data to string or a data structure.
     * 
     * If the file has not yet been added and the options is passed with a "locus" field, 
     * the file will be added.
     * 
     * The file will not be created.
     * 
     * 
     * @param {string} a_path -- a path to the file that contains the string to be read
     * @param {object} options -- if passed, an object indicating the locus of the file
     * @returns blob
     */ 
    async data_reader(a_path,options) {             // possible THROW
        let locus = this.file_locus(path,(((typeof options === "object") &amp;&amp; options.locus) ? options.locus : undefined))
        if ( !locus ) {
            if ( (typeof options === "object") &amp;&amp; options.locus ) {
                await this.add_file(path,options.locus)
                locus = this.file_locus(path,options)
            }
        }
        try {
            let file_handle = false
            if ( ( locus === "user" ) || ( locus === "opfs" ) || ( locus === "remote" ) ) {
                file_handle = this.accessed[locus].files[a_path]
                if ( file_handle ) {
                    let file = await file_handle.getFile()
                    return file
                }
            } else {
                return false
            }
        } catch(e) {
            return false
        }
    }


    /**
     * json_data_reader
     * 
     * 
     * -- read a JSON formatted file from disk
     * -- will THROW
     * 
     * @param {string} a_path -- a path to the file that contains the string to be read
     * @param {object} options -- fsPromises options
     * @returns object
     */    
    async json_data_reader(a_path,options) {             // possible THROW
        let blob = await this.data_reader(a_path,options)
        if ( blob ) {
            try {
                let str = blob.text()
                let obj = JSON.parse(str)
                return obj
            } catch (e) {}
        }
        return {}
    }


    /**
     * file_copier
     * 
     * -- copy a file from path_1 to path_2 -- assume valid paths
     * -- guards against THROW
     * 
     * @param {string} path_1 -- source path
     * @param {string} path_2 -- destination path
     * @param {object} options_1 -- needs to specify locus
     * @param {object} options_2 -- needs to specify locus
     * @returns boolean
     */
    async file_copier(path_1,path_2,options_1,options_2) {
        try {
            let file = await this.data_reader(path_1,options_1)
            if ( file ) {
                await this.write_out_string(path_2,file.text(),options_2)
                return true
            }
        } catch(e) {
            return false
        }
        return false
    }


    /**
     * ensured_file_copier
     *
     * -- copy a file from path_1 to path_2 -- assume valid paths for the source
     * -- guards against THROW
     * 
     * calls **file_copier** after calling **ensure_directories** applied to path_2.
     * 
     * @param {string} path_1 -- source path
     * @param {string} path_2 -- destination path
     * @param {object} options_1 -- needs to specify locus
     * @param {object} options_2 -- needs to specify locus
     * @returns boolean
     */
    async ensured_file_copier(path_1,path_2,options_1,options_2) {
        let status = await this.ensure_directories(path_2,false,options_2.locus,true,false)
        if ( status ) {
            status = await this.file_copier(path_1,path_2,options_1,options_2)
        }
        return status
    }


    
    /**
     * file_mover
     * 
     * -- move a file from path_1 to path_2 -- assume valid paths
     * -- guards against THROW
     * 
     * In the case of a different drive, **file_mover** calls **file_copier** and 
     * then removes the source file after the copy is successful.
     * 
     * Otherwise, calls rename.
     * 
     * @param {string} path_1 -- source path
     * @param {string} path_2 -- destination path
     * @param {object} options_1 -- needs to specify locus
     * @param {object} options_2 -- needs to specify locus
     * @returns boolean
     */
    async file_mover(path_1,path_2,options_1,options_2) {
        if ( path_1 === path_2 ) {
            return true
        }
        let status = await this.file_copier(path_1,path_2,options_1,options_2)
        if ( status ) {
            status = await this.file_remover(path_1,options_1)
        }
        return status
    }



    /**
     * ensured_file_mover
     * 
     * -- move a file from path_1 to path_2 -- assume valid paths
     * -- guards against THROW
     * 
     * **ensured_file_mover**  calls **ensured_file_copier** and then removes the source file after the copy is successful.
     * 
     * @param {string} path_1 -- source path
     * @param {string} path_2 -- destination path
     * @param {object} options_1 -- needs to specify locus
     * @param {object} options_2 -- needs to specify locus
     * @returns boolean
     */
    async ensured_file_mover(path_1,path_2,options_1,options_2) {
        let status = await this.ensured_file_copier(path_1,path_2,options_1,options_2)
        if ( status ) {
            status = await this.file_remover(path_1,options_1)
        }
        return status
    }


 
    /**
     * exists
     * 
     * -- wraps the access method -- assumes the path is a valid path
     * -- guards against THROW
     * 
     * Existence is first checked against the internal tables.
     * Failing to find a file there, the **exists** method searches the directories 
     * within the locus expected to be articulated in the options parameter.
     *
     * If the file cannot be found in either place, the file assumed to not exist.
     * This method does not look in other locations than the one that it is given.
     * 
     * If the option objects, exsits will look for the file in the first locus table that it can be found in.
     * This default behavior should be kept in mind. The locus returned may be unexpected. 
     * In some applications, providing a workable locus may be desired. In others, the locus may be more important.
     * So, the options parameter should not be ignored.
     * 
     * @param {string} path -- a path to the file under test
     * @param {object} options -- fsPromises options
     * @returns boolean
     */         
    async exists(path,options) {
        try {
            let locus = this.file_locus(path,options)
            if ( !locus ) {
                if ( ( typeof options === "object" ) &amp;&amp; options.locus ) {
                    await this.add_file(path,options.locus)
                    locus = this.file_locus(path,options)
                }
            }
            if ( !locus ) {
                return false
            }
            return true
          } catch (e) {
            return false
          }
    }

 
    /**
     * exists_dir
     * 
     * -- wraps the access method -- assumes the path is a valid path
     * -- guards against THROW
     * 
     * @param {string} path -- a path to the file under test
     * @param {object} options -- options
     * @returns boolean
     */         
    async exists_dir(path,options) {
        try {
            let locus = this.dir_locus(path,options)
            if ( !locus ) {
                if ( ( typeof options === "object" ) &amp;&amp; options.locus ) {
                    let enders = await this.dir_reader(path,options)
                    let path_list = path.split('/')
                    let ender = path_list.pop()
                    if ( ender ) {
                        if ( enders.indexOf(ender) &lt; 0 ) {
                            return false
                        }
                        return true
                    }
                }
            } else {
                return true
            }
        } catch (e) {
            return false
        }
        return false
    }


    /**
     * write_out_json
     * 
     * -- write string to file -- assume a valid path
     * -- guards against THROW
     * 
     * @param {string} path -- a path to the file that will contain the string
     * @param {object} obj -- a JSON stringifiable object
     * @param {object} options -- options
     * @returns boolean
     */
    async write_out_json(path,obj,options) {
        try {
            let str = JSON.stringify(obj)
            return await this.write_out_string(path,str,options)
        } catch (e) {
            console.log(path)
            console.log(e)
            return false
        }
    }


    /**
     * load_data_at_path
     * 
     * -- read a file from disk --- any format 
     * -- guards against THROW
     * 
     * 
     * @param {string} path -- a path to the file that contains the string to be read
     * @returns boolean | string
     */     
    async load_data_at_path(path) {
        try {
            if ( !(path) ) return false
            let data = await this.data_reader(path,options)
            return(data.text())
        } catch (e) {
            console.log(">>-------------load_data read------------------------")
            console.log(e)
            console.log(path)
            console.log("&lt;&lt;-------------------------------------")
        }
        return false
    }



    /**
     * load_json_data_at_path
     * 
     * -- read a JSON formatted file from disk
     * -- guards against THROW
     * 
     * 
     * @param {string} path -- a path to the file that contains the string to be read
     * @param {object} options -- fsPromises options
     * @returns boolean | object
     */     
    async load_json_data_at_path(path,options) {
        try {
            if ( !(path) ) return false
            return await this.json_data_reader(path,options)
        } catch (e) {
            console.log(">>-------------load_json_data read------------------------")
            console.log(e)
            console.log(path)
            console.log("&lt;&lt;-------------------------------------")
        }
        return false
    }



    /**
     * output_string
     * 
     * -- write string to file -- ensures path
     * -- guards against THROW
     * 
     * @param {string} path -- a path to the file that will contain the string
     * @param {string} str -- a string to be written
     * @param {number} options -- options -- refer to the flags for node.js writeFile having to do with permissions, format, etc.
     * @param {string} top_dir -- optional as starting point for the directory
     * @returns boolean
     */
    async output_string(path,str,options,top_dir) {
        try {
            let final_path = await this.ensure_directories(path,top_dir,options.locus,true,false)
            if ( final_path === false ) return false
            return await this.write_out_string(final_path,str,options)
        } catch (e) {
            console.log(path)
            console.log(e)
            return false
        }
    }



    /**
     * output_append_string
     * 
     * -- append string to the end of a file -- assume a valid path
     * -- guards against THROW
     * 
     * 
     * @param {string} path -- a path to the file that will contain the string
     * @param {string} str -- a string to be written
     * @param {number} options -- options -- refer to the flags for node.js writeFile having to do with permissions, format, etc.
     * @param {string} top_dir -- optional as starting point for the directory
     * @returns boolean
     */
    async output_append_string(path,str,options,top_dir) {
        try {
            let final_path = await this.ensure_directories(path,top_dir,options.locus,true,false)
            if ( final_path === false ) return false
            return await this.write_append_string(final_path,str,options)
        } catch (e) {
            console.log(path)
            console.log(e)
            return false
        }
    }
    
    

    /**
     * output_json
     * 
     * -- write string to file -- assume a valid path
     * -- guards against THROW
     * 
     * 
     * @param {string} path -- a path to the file that will contain the string
     * @param {object} obj -- a string to be written
     * @param {number} options -- options -- refer to the flags for node.js writeFile having to do with permissions, format, etc.
     * @param {string} top_dir -- optional as starting point for the directory
     * @returns boolean
     */
    async output_json(path,obj,options,top_dir) {
        try {
            let final_path = await this.ensure_directories(path,top_dir,options.locus,true,false)
            if ( final_path === false ) return false
            return await this.write_out_json(final_path,obj,ce_flags)
        } catch (e) {
            console.log(path)
            console.log(e)
            return false
        }
    }


    /**
     * 
     * watch
     * 
     * This will watch a file or directory specified by path.
     * The watch will be setup only if the file or directory has been previously
     * added to the locus table, *accessed*.
     * 
     * 
     * @param {string} path 
     * @param {Function} callback
     * @param {recursive} boolean
     * @returns boolean -- true if the path can be watched, fals otherwise
     * 
     */
    async watch(path,callback,recursive) {
        //
        let locus = this.file_locus(path)
        if ( locus ) {
            let file_handle = this.accessed[locus].files[path]
            if ( file_handle ) {
                //
                const file_callback = (records, observer) => {
                    if ( callback(records) ) {
                        observer.disconnect();
                    }
                };
                //   
                let observer = new FileSystemObserver(file_callback);

                if ( locus === 'opfs' ) {
                    const syncHandle = await file_handle.createSyncAccessHandle();
                    await observer.observe(syncHandle);
                } else {
                    this.observers[path] = observer
                    observer.observe(file_handle)
                }
            }
        } else {
            locus = this.dir_locus(path)
            if ( locus ) {
                let dir_handle = this.accessed[locus].dirs[path]
                if ( dir_handle ) {
                    //
                    const dir_callback = (records, observer) => {
                        if ( callback(records) ) {
                            observer.disconnect();
                        }
                    };
                    //   
                    let observer = new FileSystemObserver(dir_callback);
                    this.observers[path] = observer
                    observer.observe(dir_handle, { 'recursive' : recursive })
                }

            }
        }

        return false
    }

    // 1
    /**
     * copy
     * 
     * in this browser module, this is an alias for file_copier
     * 
     * @param {string} src 
     * @param {string} dest 
     * @param {object} opts 
     */
    async copy(src, dest, opts = {}) {
        try {
            if( opts.locus === undefined ) {
                opts.locus = "opfs"
            }
            //
            await this.file_copier(src,dest,opts,opts)
            //
            return true
        } catch(e) {
            console.log(e)
            return false
        }
    }


    // 2,3
    /**
     * move
     * 
     * No async for move checks on the existence of the destination file.
     * If it exsists and the opts parameter does not have a truthy field *overwrite*,
     * this will return false. Otherwse, the destination file will be replaced.
     * 
     * The destination file will be created if it does not previously exist.
     * 
     * @param {string} src 
     * @param {string} dest 
     * @param {object} opts 
     * @returns boolean
     */
    async move(src, dest, opts = {}) {
        if ( await this.exists(dest,opts) &amp;&amp; !opts.overwrite ) {
            return false
        }
        if( opts.locus === undefined ) {
            opts.locus = "opfs"
        }
        return await this.file_mover(src,dest,opts,opts) 
    }

    // 4,5
    /**
     * emptyDir
     * 
     * empties out a directory unless it does not exists.
     * If it does not exist, then it creates it with no files.
     * 
     * @param {string} dir     
     * @param {object} options 
     */
    async emptyDir(dir,options) {
        if ( !(await this.exists_dir(dir,options)) ) {   // create an empty directory
            await this.ensure_directories(dir,false,options.locus,true,false)
        } else {
            let promsises = []
            //
            let  [dir_handle,target] = this.get_parent_dirs(`${upath}/*`,options.locus)
            //
            if ( dir_handle ) {
                for await (let entry of dir_handle.keys()) {
                    promsises.push( this.dir_remover(entry,true) )
                }
                await Promise.all(promsises)
            }
        }
    }


    // 6,7
    /**
     * createFile
     * 
     * @param {string} file 
     * @returns boolean
     */
    async createFile(file) {
        return await this.file_maker(file)
    }




    // 22,23
    /**
     * outputFile
     * 
     * @param {string} path 
     * @param {string} str 
     * @param {string} encoding 
     * 
     * @returns boolean
     */
    async outputFile(path, str) {
        return await this.output_string(path,str)
    }


    // 16,17
    /**
     * outputJson
     * 
     * @param {string} file 
     * @param {object} obj 
     * @param {object} options
     *  
     * @returns boolean
     */
    async outputJson (file, obj, options = {}) {
        return await this.output_json(file,obj,options)
    }


    /**
     * readJson
     * 
     * @param {string} path 
     * @param {object} options 
     * @returns string
     */
    async readJson(path,options) {
        return this.load_json_data_at_path(path,options)
    }


    // 18,19
    /**
     * makeDir
     * 
     * also: mkdirs, mkdirp, ensureDir
     * @param {string} dir 
     * @param {object} options 
     * 
     * @returns boolean
     */
    async makeDir (dir, options) {
        return await this.dir_maker(dir,options)
    }

    /**
     * mkdirs
     * mkdirp
     * ensureDir
     * 
     * @param {string} dir 
     * @param {object} options 
     * @returns boolean
     */
    async mkdirs (dir, options) { return this.makeDir (dir, options) }
    async mkdirp (dir, options) { return this.makeDir (dir, options) }
    async ensureDir (dir, options) { return this.makeDir (dir, options) }

    /**
     * 
     * The application that wants to manipulate directories,
     * can configure the FileOperationsWeb class to provide a directory 
     * selection when they want the selection to occur. 
     * 
     * Directory selection is only available in a limited number of browsers. 
     * So, an application may use a configuration permitting these operations 
     * if it is aware that it is in a supporting browser.
     * 
     * The application configuration will proceed from within the constructor if the
     * configuration has a truthy field `dir_modal_button_id`.  This field, **`dir_modal_button_id`**
     * is usually the id of a button element some where in the web page.
     * 
     *  This method installs an **onclick** event handler on the button object.
     *  If the button does not exists, or if 'showDirectoryPicker' is not available,
     *  then, the operation will not take place nor be available later.
     * 
     * The application may choose to show a modal at some fixed time after the constructor calls this method.
     * If the configuration object has a field **`when_dir_modal`** along with another field **`dir_modal_id`**,
     * then this method will schedule a time when_dir_modal` milliseconds later to show the modal who id is `dir_modal_id`.
     * 
     * @param {object} conf 
     */
    schedule_user_dir_request(conf) {
        //
        if ( this.in_web_worker() ) return
        //
        if ( typeof conf !== 'object' ) {
            throw new Error("schedule_user_dir_request: conf parameter must be an object")
        }
        if ( !("showDirectoryPicker" in window) ) {
            console.log("showDirectoryPicker is not supported")
            return false
        }
        if ( (typeof conf.dir_modal_button_id !== "string") ) {
            console.log("no element defined for triggering directory handling")
            return false
        }
        //
        let modal_box_button = document.getElementById(conf.dir_modal_button_id)
        if ( modal_box_button ) {
            let self = this
            modal_box_button.onclick = (ev) => {
                //
                let opts = {}
                if ( self.top_dir_name ) {
                    opts.startIn = self.top_dir_name
                }
                //
                window.showDirectoryPicker(opts).then((dirHandle) => {
                    self.verifyPermission(dirHandle).then((p) => {
                        if ( p ) {
                            self.top_dir_name = dirHandle.name
                            self.top_dir = dirHandle
                        }
                    })
                })
                //
            }
            if ( conf.when_dir_modal &amp;&amp; conf.dir_modal_id ) {
                let modal_box = document.getElementById(conf.dir_modal_id)
                if ( modal_box ) {
                    setTimeout(() => {
                        modal_box.show()
                    },conf.when_dir_modal);
                }
            }
        }
    }


    /**
     * interactive_permission
     * 
     * This is called in the main thread. 
     * It uses document elements that are identified by fields provided in the 
     * class configuration passed into the constructor.
     * 
     * This is available to an application calling `dir_maker` or `file_maker`.
     * Those methods call this method if permission is still required by the time
     * they are operating.
     * 
     * @returns Promise&lt;string> resolves to the return value of a dialog
     */
    async interactive_permission() {      // must get a user event to pass permission tests
        //
        if ( this.in_web_worker() ) return false
        //
        let conf = this.conf
        if ( conf.dir_modal_id ) {
            let modal_box = document.getElementById(conf.dir_modal_id)
            if ( modal_box ) {
                let p = new Promise((resolve,reject) => {
                    modal_box.addEventListener("close", (e) => {
                        if ( favDialog.returnValue === "ok" ) {
                            resolve(favDialog.returnValue)
                        } else {
                            reject(favDialog.returnValue)
                        }
                    })
                    modal_box.show()
                })
                return p
            }
        }
    }


    /**
     * 
     * The application that wants to download files,
     * can configure the FileOperationsWeb class to provide file 
     * selection when they want the selection to occur.     
     * 
     * File selection, done by the file picker, is only available in a limited number of browsers. 
     * So, an application may use a configuration permitting these operations 
     * if it is aware that it is in a supporting browser.
     * 
     * The application configuration has a field `file_upload_modal_button_id`.  This field, **`file_upload_modal_button_id`**,
     * is usually the id of a button element somewhere in the web page.
     * 
     *  This method installs an **onclick** event handler on the button object.
     *  If the button does not exists, or if 'showOpenFilePicker' is not available,
     *  then, the operation will not take place nor be available later.
     * 
     * @param {object} conf 
     * @returns boolean
     */
    interactive_file_retrieval() {
        //
        if ( this.in_web_worker() ) return
        //
        let conf = this.conf
        //
        if ( !("showOpenFilePicker" in window) ) {
            console.log("showDirectoryPicker is not supported")
            return false
        }
        if ( (typeof conf.file_upload_modal_button_id !== "string") ) {
            console.log("no element defined for triggering file loading")
            return false
        }
        //
        let modal_box_button = document.getElementById(conf.file_upload_modal_button_id)
        if ( modal_box_button ) {
            let self = this
            modal_box_button.onclick = (ev) => {
                //
                window.showDirectoryPicker().then((dirHandle) => {
                    self.verifyPermission(dirHandle).then((p) => {
                        if ( p ) {
                            self.top_dir = dirHandle
                            self.top_dir_name = dirHandle.name
                        }
                    })
                })
                //
            }
            return true
        }
        //
        return false
    }



    /**
     * 
     * The application that wants to download files,
     * can configure the FileOperationsWeb class to provide file 
     * selection when they want the selection to occur. 
     * 
     * File selection, done by the file picker, is only available in a limited number of browsers. 
     * So, an application may use a configuration permitting these operations 
     * if it is aware that it is in a supporting browser.
     * 
     * The application configuration has a field `file_dowload_modal_button_id`.
     * This field, **`file_dowload_modal_button_id`**,
     * is usually the id of a button element somewhere in the web page.
     * 
     *  This method installs an **onclick** event handler on the button object.
     *  If the button does not exists, or if 'showSaveFilePicker' is not available,
     *  then, the operation will not take place nor be available later.
     * 
     * @param {object} conf 
     * @returns boolean
     */
    interactive_file_download() {
        //
        if ( this.in_web_worker() ) return
        //
        let conf = this.conf

        if ( !("showSaveFilePicker" in window) ) {
            console.log("showDirectoryPicker is not supported")
            return false
        }
        if ( (typeof conf.file_dowload_modal_button_id !== "string") ) {
            console.log("no element defined for triggering file loading")
            return false
        }

        let modal_box_button = document.getElementById(conf.file_dowload_modal_button_id)
        if ( modal_box_button ) {
            let self = this
            modal_box_button.onclick = (ev) => {
                //
                window.showDirectoryPicker().then((dirHandle) => {
                    self.verifyPermission(dirHandle).then((p) => {
                        if ( p ) {
                            self.top_dir = dirHandle
                        }
                    })
                })
                //
            }
            return true
        }
        return false
    }

    /**
     * At the time of this release,
     * the directory picker is available to some but not all browsers.
     * If the directory picker is not available,then it can be assumed that the file picker
     * is not available.
     * 
     * @returns boolean
     */
    check_user_dir_support() {
        //
        if ( this.in_web_worker() ) return
        //
        if ( !("showDirectoryPicker" in window) ) {
            console.log("showDirectoryPicker is not supported")
            return false
        }
        return true
    }

}




/**
 * @classdesc
 * 
 * This class uses the synch methods for writing and reading. 
 * The idea was to use the sync methods in FileOperations corresponding to calls
 * similarly named in fs-extra. However, nothing can be really synchronouse in these
 * methods except that finale read and write calls. 
 * 
 * It is possible to have method that returns the synchronous operations handle.
 * The benefit is that the same bookkeeping for files in FileOperationsWeb
 * can be used to gain access to the handles.
 * (See `get_sync_readable` and `get_sync_writeable`)
 *
 */

class FileOperationsWebSync extends FileOperationsWeb {

    /**
     * 
     * The constructor gets a hanlde to the Origin Private File System.
     * (It uses the promise "then" construct... )
     * And, it gets a handel to the user permitted device file system. 
     * If configured to do so.
     * 
     * The constructor also sets up a cache for file handles in the different file systems for later 
     * searching and access. The cache is an a JavaScript object with three top level fields "opfs", "user", and "remote".
     * 
     * Each of these has two maps, "files" and "changed". The "files" will map file paths to file handles. 
     * 
     * 
     * @param {object} conf 
     */
    constructor (conf) {
        super(conf)
        this.opfs_root = false;
    }



    /**
     * copySync
     * 
     * This method copies two files using the Sync Access Handle.
     * This method will only operate in a Worker thread. Furthermore, 
     * the file system has to be OPFS in any case. 
     * 
     * A second opts_d is provided in case this method can actually 
     * write to something other than OPFS if there ever is one.
     * 
     * For copying between two different file systems, 
     * use `file_copier` or `ensure_file_copier`
     * 
     * @param {string} src -- The file to be copied
     * @param {string} dest -- The file being created or overwritten
     * @param {object} opts -- opts should have a field "locus"
     * @param {object} opts_d -- opts_d should have a field "locus" for the destination
     */
    async copySync(src, dest, opts = {}, opts_d = {}) {
        try {
            if ( opts === undefined ) {
                opts = { "locus" : "opfs" }
            }
            if ( await this.exists(src,opts) ) {
                let locus = this.file_locus(src,opts)
                let src_file_handle = this.accessed[locus].files[src]


                if ( opts_d === undefined ) opts_d = opts

                if ( !(await this.exists(dest,opts_d)) ) {
                    await this.file_maker(dest,opts_d)
                }
                let locus_d = this.file_locus(dest,opts_d)
                if ( locus &amp;&amp; locus_d ) {
                    let dest_file_handle = this.accessed[locus_d].files[dest]
                    if ( src_file_handle &amp;&amp; dest_file_handle ) {
                        const accessHandle = await src_file_handle.createSyncAccessHandle({
                                                                            mode: "readwrite-unsafe",
                                                                        });
                        let size = accessHandle.getSize();

                        const dataView = new DataView(new ArrayBuffer(size));
                        accessHandle.read(dataView, { at: 0 });

                        //let data = this.textDecoder.decode(dataView)

                        // Always close FileSystemSyncAccessHandle if done.
                        accessHandle.close();

                        const outHandle = await dest_file_handle.createSyncAccessHandle({
                                                                            mode: "readwrite-unsafe",
                                                                        });
                        outHandle.write(dataView,{ at : 0 })
                        outHandle.truncate(size)
                        outHandle.flush()
                        outHandle.close()
                        return true
                    }
                }
            }
            //
        } catch(e) {
            console.log(e)
            return false
        }
        return false
    }


    /**
     * Returns a SyncAccessHandle. The handle should be good for reading.
     * Use `sync_read_at_path` or `sync_read`. Close the handle with `close_async`
     * 
     * This method maps the file pathname *src* to the access handle by storing it in 
     * the readables part of the `sync_handles` table. Some methods may allow for the path to 
     * lookup the handle in order to access reading and writing.
     * 
     * @param {string} src - a path to the file
     * @param {object} opts -- optional will default to { "locus" : "opfs" }
     * @returns boolean | object - returns a Sync Access Handle if successful, otherwise false
     */
    async get_sync_readable(src,opts) {
        try {
            if ( opts === undefined ) {
                opts = { "locus" : "opfs" }
            } else if ( opts.locus === undefined ) {
                opts.locus = "opfs"
            }
            if ( await this.exists(src,opts) ) {
                let locus = this.file_locus(src,opts)
                let src_file_handle = this.accessed[locus].files[src]
                if ( src_file_handle ) {
                    const accessHandle = await src_file_handle.createSyncAccessHandle({
                                                                        mode: "readwrite-unsafe",
                                                                    });
                    this.sync_handles.readables[src] = accessHandle
                    return accessHandle
                }
            }
        } catch (e) {
            console.log(e)
            return false
        }
    }


    /**
     * Returns a SyncAccessHandle. The handle should be good for writing.
     * Use `sync_write_at_path` or `sync_write`. Close the handle with `close_sync`
     * 
     * This method maps the file pathname *path* to the access handle by storing it in 
     * the writeables part of the `sync_handles` table. Some methods may allow for the path to 
     * lookup the handle in order to access reading and writing.
     * 
     * @param {string} path - a path to the file
     * @param {object} opts -- optional will default to { "locus" : "opfs" }
     * @returns boolean | object - returns a Sync Access Handle if successful, otherwise false
     */
    async get_sync_writeable(path,opts) {
        try {
            if ( opts === undefined ) {
                opts = { "locus" : "opfs" }
            } else if ( opts.locus === undefined ) {
                opts.locus = "opfs"
            }
            if ( await this.exists(path,opts) ) {
                let locus = this.file_locus(path,opts)
                let path_file_handle = this.accessed[locus].files[path]
                if ( path_file_handle ) {
                    const accessHandle = await path_file_handle.createSyncAccessHandle({
                                                                        mode: "readwrite-unsafe",
                                                                    });
                    this.sync_handles.writeables[path] = accessHandle
                    return accessHandle
                }
            }
        } catch (e) {
            console.log(e)
            return false
        }
    }


    /**
     * Given an active sync access handle good for reading, 
     * this will read the data and return it as a string.
     * 
     * It will decide how to use the bounds parameter to get the offset into the file.
     * If the bounds parameter is not used, it will start reading at position 0.
     * 
     * @param {object} accessHandle - returned by `get_sync_readable`
     * @param {number | object} bounds - the offset into the file from where the data will be read 
     * @returns string | boolean - returns the data in the file as a string, otherwise false if something goes wrong.
     */
    sync_read(accessHandle,bounds) {
        let size = accessHandle.getSize();
        const dataView = new DataView(new ArrayBuffer(size));
        if ( bounds ) {
            if ( typeof bounds === "number" ) {
                accessHandle.read(dataView, { at: bounds });
            } else if ( typeof bounds === "object" ) {
                accessHandle.read(dataView, { at: bounds.lb });
            } else {
                return false
            }
        } else {
            accessHandle.read(dataView, { at: 0 });
        }
        let data = this.textDecoder.decode(dataView)
        return data
    }


    /**
     * 
     * This method allows for the path to 
     * lookup the handle in order to access reading.
     * 
     * If the handle can be found, this method calls the method `sync_read`.
     * 
     * @param {string} path 
     * @param {number | object} bounds 
     * @returns string | boolean - returns the data in the file as a string, otherwise false if something goes wrong.
     */
    sync_read_at_path(path,bounds) {
        let accessHandle = this.sync_handles.readables[path]
        if ( accessHandle ) {
            return this.sync_read(accessHandle,bounds)
        }
        return false
    }


    /**
     * Given an active sync access handle good for writing, 
     * this will write the data taken in as a string into a buffer and then into a file.
     * 
     * It will decide how to use the bounds parameter to get the offset into the file.
     * If the bounds parameter is not used, it will start writing at position 0.
     * 
     * @param {object} accessHandle - returned by `get_sync_readable`
     * @param {string} str -- string to be written to the file
     * @param {number | object} bounds - the offset into the file where the data will be written 
     * @returns 
     */
    sync_write(accessHandle,str,bounds) {
        const content = this.textEncoder.encode(str);
        if ( bounds ) {
            if ( typeof bounds === "number" ) {
                accessHandle.write(content,  { at: bounds });
            } else if ( typeof bounds === "object" ) {
                accessHandle.write(content,  { at: bounds.lb });
            } else {
                return false
            }
        } else {
            accessHandle.write(content, { at: 0 });
        }
        return true
    }


    /**
     * 
     * This method allows for the path to 
     * lookup the handle in order to access writing.
     * 
     * If the handle can be found, this method calls the method `sync_write`.
     * 
     * @param {string} path
     * @param {number | object} bounds 
     * @returns boolean
     */
    sync_write_at_path(path,data,bounds) {
        let accessHandle = this.sync_handles.readables[path]
        if ( accessHandle ) {
            return this.sync_write(accessHandle,data,bounds)
        }
        return false
    }


    /**
     * Looks in the readable and writable tables for the handle.
     * If this method finds the handle, it calls close on it.
     * 
     * If the handle is for writing, then this calls the method `flush`.
     * 
     * @param {string} path 
     */
    close_sync(path) {
        let accessHandle = this.sync_handles.writeables[path]
        if ( accessHandle ) {
            accessHandle.close()
            return true
        } else {
            accessHandle = his.sync_handles.readables[path]
            if ( accessHandle ) {
                accessHandle.flush()
                accessHandle.close()
                return true
            }
        }
        return false
    }



    /**
     * readFileSync
     * 
     * Reads data from a file starting at 0 or at a position indicated at bounds.
     * 
     * @param {string} src
     * @param {object} opts -- the opts required by `get_sync_readable`
     * @param {number | object} bounds -- the bounds required by `sync_read`
     * @returns string
     */
    async readFileSync(src,opts,bounds) {
        //
        try {
            let accessHandle = this.get_sync_readable(src,opts)
            if ( accessHandle ) {
                let data = this.sync_read(accessHandle,bounds)
                if ( data ) {
                    this.close_sync(src)
                }
            }
        } catch (e) {
            console.log(e)
            return false
        }
        //
    }


    /**
     * outputFileSync
     * 
     * Writes data to a file starting at 0 or at a position indicated at bounds.
     * 
     * @param {string} file
     * @param {string} str
     * @param {object} opts -- the ops required by `get_sync_writeable`
     * @param {number | object} bounds -- the bounds required by `sync_write`
     * 
     * @returns boolean
     */
    async outputFileSync(file,str,opts) {
        //
        try {
            let accessHandle = this.get_sync_writeable(file,opts)
            if ( accessHandle ) {
                if ( this.sync_write(accessHandle,str,bounds) ) {
                    this.close_sync(file)
                }
            }
        } catch (e) {
            console.log(e)
            return false
        }
        //
        return true
    }


    /**
     * outputJsonSync
     * 
     * @param {string} file -- file path
     * @param {object} obj -- object this file turns into a string before calling `outputFileSync`
     * @param {object} opts -- the ops required by `get_sync_writeable`
     * @returns boolean
     */
    async outputJsonSync(file, obj, options) {
        try {
            let str = JSON.stringify(obj)
            return await this.outputFileSync(file,str,opts)
        } catch (e) {
            console.log(path)
            console.log(e)
            return false
        }
    }

    
    /**
     * readJsonSync
     * 
     * @param {string} file 
     * @param {object} opts -- the opts required by `get_sync_readable`
     * @param {number | object} bounds -- the bounds required by `sync_read`
     * @returns boolean | object -- the object parsed from JSON stored in the file
     * 
     */
    async readJsonSync(file,opts) {
        try {
            let str_data = await this.readFileSync(file,opts)
            let obj = JSON.parse(str_data)
            return obj
        } catch(e) {
            return false
        }
    }


    // 25
    /**
     * pathExists
     * 
     * this is an alias
     * 
     * @param {string} path 
     * @returns boolean
     */
    async pathExists(path) {
        return await this.exists(path)
    }


}

</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.5</a> on Mon Nov 24 2025 23:59:40 GMT-0800 (Pacific Standard Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>


<script src="scripts/collapse.js" defer></script>


</body>
</html>
